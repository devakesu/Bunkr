name: CI/CD Pipeline

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]
  merge_group:
    branches: [main]

permissions:
  contents: read

jobs:
  # This job acts as a prerequisite for the pipeline. It runs on EVERY PR, push, and merge queue (merge_group) run.
  # Currently performs repository checkout to prepare for subsequent jobs.
  # For formal releases with versioning and signed artifacts, see .github/workflows/release.yml
  guard:
    name: Build Guard
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
  # Auto-tag releases on main branch
  # This simplified job creates signed tags from version bumps made in PRs
  # The version bump now happens at PR creation time via auto-version-bump.yml
  auto-tag:
    name: Auto Tag Release
    needs: guard
    if: |
      github.event_name == 'push' &&
      github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0

      - name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6.3.0
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}
          git_tag_gpgsign: true
          git_user_signingkey: true

      - name: Setup Node.js
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v6.2.0
        with:
          node-version: '20'

      - name: Create and push signed tag
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          VERSION=$(node -p "require('./package.json').version")
          VERSION_TAG="v${VERSION}"

          echo "Current version: ${VERSION}"
          echo "Tag to create: ${VERSION_TAG}"

          # Check if tag already exists
          if git ls-remote --tags origin | grep -q "refs/tags/${VERSION_TAG}$"; then
            echo "Tag ${VERSION_TAG} already exists, skipping"
            exit 0
          fi

          echo "Creating signed tag ${VERSION_TAG}"

          # Configure git identity for tagging (GPG action sets signing config)
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Create signed annotated tag
          git tag -a "${VERSION_TAG}" -m "Release ${VERSION_TAG}"

          # Push tag (handle possible concurrent creation)
          set +e
          git push origin "${VERSION_TAG}"
          push_status=$?
          set -e

          if [ $push_status -ne 0 ]; then
            echo "git push for tag ${VERSION_TAG} failed with status ${push_status}, checking if tag exists on remote..."
            if git ls-remote --tags origin | grep -q "refs/tags/${VERSION_TAG}$"; then
              echo "Tag ${VERSION_TAG} already exists on remote (likely created concurrently); continuing."
            else
              echo "✗ Failed to push tag ${VERSION_TAG} and tag not found on remote."
              exit $push_status
            fi
          fi

          echo "✓ Tag ${VERSION_TAG} created and pushed"

          # Trigger release workflow via repository_dispatch
          echo "Triggering release workflow via repository_dispatch"

          # Add retry logic for transient failures
          max_attempts=3
          attempt=1

          while [ $attempt -le $max_attempts ]; do
            if gh api repos/${{ github.repository }}/dispatches \
              --method POST \
              -H "Accept: application/vnd.github+json" \
              -f event_type="release_requested" \
              -f client_payload[version_tag]="${VERSION_TAG}" \
              -f client_payload[triggered_by]="auto-tag" \
              -f client_payload[run_id]="${{ github.run_id }}"; then
              echo "✓ Release workflow triggered for ${VERSION_TAG}"
              break
            fi

            if [ $attempt -eq $max_attempts ]; then
              echo "✗ Failed to trigger release workflow after ${max_attempts} attempts"
              exit 1
            fi

            echo "Retry attempt ${attempt}/${max_attempts} in 5s..."
            sleep 5
            attempt=$((attempt + 1))
          done
