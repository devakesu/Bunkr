name: Auto Version Bump

on:
  pull_request:
    # Triggers on opened, reopened, and synchronize to handle:
    # - opened: Initial PR creation
    # - reopened: When a closed PR is reopened
    # - synchronize: When PR is updated (e.g., after rebase/merge from main)
    # The check step will detect if version is already bumped and skip if not needed
    types: [opened, reopened, synchronize]
    branches: [main]

# Prevent concurrent runs for the same PR
concurrency:
  group: auto-version-bump-${{ github.event.pull_request.number }}
  cancel-in-progress: true

# Default to read-only permissions
permissions:
  contents: read

jobs:
  auto-bump:
    name: Auto Bump Version
    runs-on: ubuntu-latest
    # Elevate permissions only for this job
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Determine if same-repo or fork
        id: repo-check
        run: |
          # Check if this is a Dependabot PR
          if [ "${{ github.actor }}" = "dependabot[bot]" ] || [[ "${{ github.head_ref }}" == dependabot/* ]]; then
            echo "is_dependabot=true" >> $GITHUB_OUTPUT
            echo "is_same_repo=true" >> $GITHUB_OUTPUT
            echo "âœ“ Dependabot PR detected - will skip GPG signing"
          elif [ "${{ github.event.pull_request.head.repo.full_name }}" = "${{ github.repository }}" ]; then
            echo "is_dependabot=false" >> $GITHUB_OUTPUT
            echo "is_same_repo=true" >> $GITHUB_OUTPUT
            echo "âœ“ Same-repo PR - can auto-commit version bump"
          else
            echo "is_dependabot=false" >> $GITHUB_OUTPUT
            echo "is_same_repo=false" >> $GITHUB_OUTPUT
            echo "âœ“ Fork PR - will provide manual instructions"
          fi

      - name: Checkout PR branch (same-repo only)
        if: steps.repo-check.outputs.is_same_repo == 'true'
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          # Use BOT_PAT to trigger workflows after version bump commit
          # Falls back to GITHUB_TOKEN if BOT_PAT is not configured
          token: ${{ secrets.BOT_PAT || secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Checkout PR head (fork PR)
        if: steps.repo-check.outputs.is_same_repo == 'false'
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Import GPG key (same-repo non-Dependabot only)
        if: steps.repo-check.outputs.is_same_repo == 'true' && steps.repo-check.outputs.is_dependabot != 'true'
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6.3.0
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}
          git_user_signingkey: true
          git_commit_gpgsign: true
          git_config_global: true
          # IMPORTANT: Use the same name and email as in your GPG key
          # This email MUST be verified in your GitHub account for commits to show as "Verified"
          git_committer_name: ${{ secrets.GPG_COMMITTER_NAME || 'GhostClass Bot' }}
          git_committer_email: ${{ secrets.GPG_COMMITTER_EMAIL || '61821107+devakesu@users.noreply.github.com' }}

      - name: Setup Node.js
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v6.2.0
        with:
          node-version: '20'

      - name: Check if version needs bump
        id: check
        run: |
          set -euo pipefail

          # Get current version from PR branch
          CURRENT=$(node -p "require('./package.json').version")
          echo "Current version on PR branch: ${CURRENT}"

          # Get version from main branch
          git fetch origin main
          MAIN_VERSION=$(git show origin/main:package.json | node -p "JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8')).version")
          echo "Version on main branch: ${MAIN_VERSION}"

          # Calculate next version for reference
          NEXT_VERSION=$(node -e "
            const version = '${MAIN_VERSION}';
            let parts = version.split('.').map(Number);

            // Normalize first
            if (parts[2] > 9) { parts[2] = 0; parts[1] += 1; }
            if (parts[1] > 9) { parts[1] = 0; parts[0] += 1; parts[2] = 0; }

            // Increment
            parts[2] += 1;
            if (parts[2] > 9) {
              parts[2] = 0;
              parts[1] += 1;
              if (parts[1] > 9) {
                parts[1] = 0;
                parts[0] += 1;
              }
            }
            console.log(parts.join('.'));
          ")
          echo "next_version=${NEXT_VERSION}" >> $GITHUB_OUTPUT

          # Check if version needs bump or already bumped
          if [ "$CURRENT" = "$MAIN_VERSION" ]; then
            echo "needs_bump=true" >> $GITHUB_OUTPUT
            echo "current_version=$MAIN_VERSION" >> $GITHUB_OUTPUT
            echo "âœ“ Version needs bump (matches main: ${MAIN_VERSION})"
          else
            echo "needs_bump=false" >> $GITHUB_OUTPUT
            echo "current_version=$CURRENT" >> $GITHUB_OUTPUT
            echo "âœ“ Version already bumped (current: ${CURRENT}, main: ${MAIN_VERSION})"
          fi

      - name: Auto bump version (same-repo non-Dependabot)
        if: steps.repo-check.outputs.is_same_repo == 'true' && steps.check.outputs.needs_bump == 'true' && steps.repo-check.outputs.is_dependabot != 'true'
        id: bump
        env:
          PR_HEAD_REF: ${{ github.head_ref }}
        run: |
          set -euo pipefail

          echo "Running bump-version.js script..."

          # Set GITHUB_HEAD_REF to a safe placeholder value for the Node.js script
          # The script only checks if this var exists (for PR context detection)
          # PR_HEAD_REF is used only to checkout the branch for pushing (see git checkout at line 153)
          export GITHUB_HEAD_REF="pr-branch"
          export CI="true"

          # Run the bump script
          node scripts/bump-version.js

          # Get the new version
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "âœ“ Version bumped to ${NEW_VERSION}"

          # Checkout the branch to avoid detached HEAD state for pushing
          # Using env var to safely pass branch name
          BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
          if [ "$BRANCH_NAME" = "HEAD" ]; then
            # We're in detached HEAD, need to checkout the branch
            git checkout -B "$PR_HEAD_REF"
          fi

          # Git identity is configured globally by the GPG action
          # Stage and commit changes
          # Note: Files are explicitly listed (not git add -u) to ensure only version files are committed
          # This matches the files updated by bump-version.js
          git add package.json package-lock.json .example.env public/api-docs/openapi.yaml

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "âš ï¸  No changes to commit after running bump script"
            exit 0
          fi

          git commit -m "chore: auto-bump version to v${NEW_VERSION}"
          git push --set-upstream origin "$PR_HEAD_REF"

          echo "âœ“ Changes committed and pushed"

      - name: Auto bump version (Dependabot PR via API)
        if: steps.repo-check.outputs.is_same_repo == 'true' && steps.check.outputs.needs_bump == 'true' && steps.repo-check.outputs.is_dependabot == 'true'
        id: bump-dependabot
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');

            // Run the bump script
            console.log('Running bump-version.js script...');
            execSync('CI=true GITHUB_HEAD_REF="pr-branch" node scripts/bump-version.js', {
              stdio: 'inherit',
              cwd: process.env.GITHUB_WORKSPACE
            });

            // Get the new version
            const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            const newVersion = packageJson.version;
            console.log(`âœ“ Version bumped to ${newVersion}`);
            core.setOutput('new_version', newVersion);

            // Read updated file contents
            const packageJsonContent = fs.readFileSync('package.json', 'utf8');
            const packageLockContent = fs.readFileSync('package-lock.json', 'utf8');
            const exampleEnvContent = fs.readFileSync('.example.env', 'utf8');
            const openapiContent = fs.readFileSync('public/api-docs/openapi.yaml', 'utf8');

            // Get current commit SHA
            const branch = context.payload.pull_request.head.ref;
            const { data: refData } = await github.rest.git.getRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `heads/${branch}`
            });
            const currentCommitSha = refData.object.sha;

            // Get the current commit to retrieve the tree
            const { data: currentCommit } = await github.rest.git.getCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: currentCommitSha
            });

            // Create blobs for each file
            const blobs = await Promise.all([
              github.rest.git.createBlob({
                owner: context.repo.owner,
                repo: context.repo.repo,
                content: Buffer.from(packageJsonContent).toString('base64'),
                encoding: 'base64'
              }),
              github.rest.git.createBlob({
                owner: context.repo.owner,
                repo: context.repo.repo,
                content: Buffer.from(packageLockContent).toString('base64'),
                encoding: 'base64'
              }),
              github.rest.git.createBlob({
                owner: context.repo.owner,
                repo: context.repo.repo,
                content: Buffer.from(exampleEnvContent).toString('base64'),
                encoding: 'base64'
              }),
              github.rest.git.createBlob({
                owner: context.repo.owner,
                repo: context.repo.repo,
                content: Buffer.from(openapiContent).toString('base64'),
                encoding: 'base64'
              })
            ]);

            // Create a new tree with updated files
            const { data: newTree } = await github.rest.git.createTree({
              owner: context.repo.owner,
              repo: context.repo.repo,
              base_tree: currentCommit.tree.sha,
              tree: [
                { path: 'package.json', mode: '100644', type: 'blob', sha: blobs[0].data.sha },
                { path: 'package-lock.json', mode: '100644', type: 'blob', sha: blobs[1].data.sha },
                { path: '.example.env', mode: '100644', type: 'blob', sha: blobs[2].data.sha },
                { path: 'public/api-docs/openapi.yaml', mode: '100644', type: 'blob', sha: blobs[3].data.sha }
              ]
            });

            // Create a new commit (GitHub will sign this automatically)
            const { data: newCommit } = await github.rest.git.createCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              message: `chore: auto-bump version to v${newVersion}`,
              tree: newTree.sha,
              parents: [currentCommitSha],
              author: {
                name: 'github-actions[bot]',
                email: '41898282+github-actions[bot]@users.noreply.github.com'
              },
              committer: {
                name: 'github-actions[bot]',
                email: '41898282+github-actions[bot]@users.noreply.github.com'
              }
            });

            // Update the branch reference
            await github.rest.git.updateRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `heads/${branch}`,
              sha: newCommit.sha,
              force: false
            });

            console.log('âœ“ Changes committed and pushed via GitHub API (signed by GitHub)');
            return newVersion;

      - name: Comment on PR (same-repo with auto-bump)
        if: steps.repo-check.outputs.is_same_repo == 'true' && steps.check.outputs.needs_bump == 'true' && (steps.bump.outputs.new_version != '' || steps.bump-dependabot.outputs.new_version != '')
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const newVersion = '${{ steps.bump.outputs.new_version }}' || '${{ steps.bump-dependabot.outputs.new_version }}';
            const isDependabot = '${{ steps.repo-check.outputs.is_dependabot }}' === 'true';

            // Check for existing bump comments to avoid spam on synchronize events
            const { data: comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });

            const bumpPrefix = 'âœ… **Version automatically bumped to';
            const existingBumpComment = comments
              .slice()
              .reverse()
              .find((comment) => {
                const isBot = comment.user && comment.user.type === 'Bot';
                const hasPrefix = typeof comment.body === 'string' && comment.body.startsWith(bumpPrefix);
                return isBot && hasPrefix;
              });

            const isRebump = !!existingBumpComment;
            const rebumpNote = isRebump
              ? '\n\n_Note: A previous automatic bump was performed. This is a re-bump after the PR was updated (e.g., rebased or synced with main)._'
              : '';
            
            const signingNote = isDependabot
              ? '\n\n_Note: This commit was created via GitHub API and is signed by GitHub (not custom GPG), as Dependabot PRs don\'t have access to repository secrets._'
              : '';

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `âœ… **Version automatically bumped to \`v${newVersion}\`**

            This PR now includes the version bump commit.${rebumpNote}${signingNote}

            **Rollover versioning:** X.Y.Z where X â‰¥ 0 and Y, Z âˆˆ {0-9}
            - Example: 1.6.9 â†’ 1.7.0, 1.9.9 â†’ 2.0.0, 9.9.9 â†’ 10.0.0

            This PR is ready for review! ðŸš€`
            });

      - name: Comment on PR (same-repo, already bumped)
        if: steps.repo-check.outputs.is_same_repo == 'true' && steps.check.outputs.needs_bump == 'false' && github.event.action != 'synchronize'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const currentVersion = '${{ steps.check.outputs.current_version }}';
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `âœ… **Version already bumped to \`v${currentVersion}\`**

            No automatic version bump needed - the PR already includes a version update.

            This PR is ready for review! ðŸš€`
            });

      - name: Comment on PR (fork, needs bump)
        if: steps.repo-check.outputs.is_same_repo == 'false' && steps.check.outputs.needs_bump == 'true' && github.event.action != 'synchronize'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const nextVersion = '${{ steps.check.outputs.next_version }}';
            const currentVersion = '${{ steps.check.outputs.current_version }}';
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ðŸ‘‹ **Thank you for your contribution from a fork!**

            Since this PR is from a forked repository, the automatic version bump cannot run (for security reasons).

            **Please manually bump the version before merging:**

            \`\`\`bash
            # Current version on main: ${currentVersion}
            # Suggested next version: ${nextVersion}

            # From your PR branch, run the version bump script with PR context:
            CI=true GITHUB_HEAD_REF="$(git rev-parse --abbrev-ref HEAD)" node scripts/bump-version.js
            \`\`\`

            The script will update:
            - \`package.json\` and \`package-lock.json\`
            - \`.example.env\` (NEXT_PUBLIC_APP_VERSION)
            - \`public/api-docs/openapi.yaml\`

            **Rollover versioning:** X.Y.Z where X â‰¥ 0 and Y, Z âˆˆ {0-9}
            - Example: 1.6.9 â†’ 1.7.0, 1.9.9 â†’ 2.0.0, 9.9.9 â†’ 10.0.0

            For more details, see [VERSIONING.md](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/docs/VERSIONING.md).`
            });

      - name: Comment on PR (fork, already bumped)
        if: steps.repo-check.outputs.is_same_repo == 'false' && steps.check.outputs.needs_bump == 'false' && github.event.action != 'synchronize'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const currentVersion = '${{ steps.check.outputs.current_version }}';
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `âœ… **Version already bumped to \`v${currentVersion}\`**

            Great! This PR already includes a version update.

            This PR is ready for review! ðŸš€`
            });
