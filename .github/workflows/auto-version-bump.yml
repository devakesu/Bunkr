name: Auto Version Bump

on:
  pull_request:
    # Triggers on opened, reopened, and synchronize to handle:
    # - opened: Initial PR creation
    # - reopened: When a closed PR is reopened
    # - synchronize: When PR is updated (e.g., after rebase/merge from main)
    # The check step will detect if version is already bumped and skip if not needed
    types: [opened, reopened, synchronize]
    branches: [main]

# Prevent concurrent runs for the same PR
concurrency:
  group: auto-version-bump-${{ github.event.pull_request.number }}
  cancel-in-progress: true

# Default to read-only permissions
permissions:
  contents: read

jobs:
  auto-bump:
    name: Auto Bump Version
    runs-on: ubuntu-latest
    # Elevate permissions only for this job
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Determine if same-repo or fork
        id: repo-check
        run: |
          # Check if this is a Dependabot PR
          if [ "${{ github.actor }}" = "dependabot[bot]" ] || [[ "${{ github.head_ref }}" == dependabot/* ]]; then
            echo "is_dependabot=true" >> $GITHUB_OUTPUT
            echo "is_same_repo=true" >> $GITHUB_OUTPUT
            echo "‚úì Dependabot PR detected - will skip GPG signing"
          elif [ "${{ github.event.pull_request.head.repo.full_name }}" = "${{ github.repository }}" ]; then
            echo "is_dependabot=false" >> $GITHUB_OUTPUT
            echo "is_same_repo=true" >> $GITHUB_OUTPUT
            echo "‚úì Same-repo PR - can auto-commit version bump"
          else
            echo "is_dependabot=false" >> $GITHUB_OUTPUT
            echo "is_same_repo=false" >> $GITHUB_OUTPUT
            echo "‚úì Fork PR - will provide manual instructions"
          fi

      - name: Validate BOT_PAT secret
        if: steps.repo-check.outputs.is_same_repo == 'true'
        run: |
          if [ -z "${{ secrets.BOT_PAT }}" ]; then
            echo "::warning::BOT_PAT secret is not configured. Version bump commits will use GITHUB_TOKEN."
            echo "::warning::‚ö†Ô∏è  IMPORTANT: Commits made with GITHUB_TOKEN will NOT trigger workflows (Tests, Pipeline, etc.)"
            echo "::warning::This means CI checks won't run automatically after the version bump."
            echo ""
            echo "To fix this:"
            echo "1. Create a Personal Access Token (Classic) with 'repo' and 'workflow' scopes"
            echo "2. Add it as a repository secret named 'BOT_PAT'"
            echo "3. Re-run this workflow or push a new commit"
            echo ""
            echo "Note: Dependabot bump commits will be unverified regardless of BOT_PAT (GPG signing is skipped)."
            echo "has_bot_pat=false" >> $GITHUB_OUTPUT
          else
            echo "‚úì BOT_PAT is configured - workflows will trigger after version bump"
            echo "has_bot_pat=true" >> $GITHUB_OUTPUT
          fi
        id: validate-token

      - name: Checkout PR branch (same-repo only)
        if: steps.repo-check.outputs.is_same_repo == 'true'
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          # IMPORTANT: BOT_PAT is REQUIRED for downstream workflows to trigger after the version bump
          # - BOT_PAT: Personal Access Token with 'repo' and 'workflow' scopes (allows follow-up workflows to run)
          # - GITHUB_TOKEN: Fallback that works but WON'T trigger other workflows due to GitHub security restrictions
          # For Dependabot PRs, this workflow skips GPG signing, so bump commits appear as unverified regardless of token; BOT_PAT here only affects whether downstream workflows are triggered
          token: ${{ secrets.BOT_PAT || secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Checkout PR head (fork PR)
        if: steps.repo-check.outputs.is_same_repo == 'false'
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          fetch-depth: 0

      - name: Import GPG key (same-repo non-Dependabot only)
        if: steps.repo-check.outputs.is_same_repo == 'true' && steps.repo-check.outputs.is_dependabot != 'true'
        uses: crazy-max/ghaction-import-gpg@e89d40939c28e39f97cf32126055eeae86ba74ec # v6.3.0
        with:
          gpg_private_key: ${{ secrets.GPG_PRIVATE_KEY }}
          passphrase: ${{ secrets.GPG_PASSPHRASE }}
          git_user_signingkey: true
          git_commit_gpgsign: true
          git_config_global: true
          # IMPORTANT: Use the same name and email as in your GPG key
          # This email MUST be verified in your GitHub account for commits to show as "Verified"
          git_committer_name: ${{ secrets.GPG_COMMITTER_NAME || 'GhostClass Bot' }}
          git_committer_email: ${{ secrets.GPG_COMMITTER_EMAIL || '61821107+devakesu@users.noreply.github.com' }}

      - name: Setup Node.js
        uses: actions/setup-node@6044e13b5dc448c55e2357c09f80417699197238 # v6.2.0
        with:
          node-version: '20'

      - name: Check if version needs bump
        id: check
        run: |
          set -euo pipefail

          # Get current version from PR branch
          CURRENT=$(node -p "require('./package.json').version")
          echo "Current version on PR branch: ${CURRENT}"

          # Get version from main branch
          git fetch origin main
          MAIN_VERSION=$(git show origin/main:package.json | node -p "JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8')).version")
          echo "Version on main branch: ${MAIN_VERSION}"

          # Calculate next version for reference
          NEXT_VERSION=$(node -e "
            const version = '${MAIN_VERSION}';
            let parts = version.split('.').map(Number);

            // Normalize first
            if (parts[2] > 9) { parts[2] = 0; parts[1] += 1; }
            if (parts[1] > 9) { parts[1] = 0; parts[0] += 1; parts[2] = 0; }

            // Increment
            parts[2] += 1;
            if (parts[2] > 9) {
              parts[2] = 0;
              parts[1] += 1;
              if (parts[1] > 9) {
                parts[1] = 0;
                parts[0] += 1;
              }
            }
            console.log(parts.join('.'));
          ")
          echo "next_version=${NEXT_VERSION}" >> $GITHUB_OUTPUT

          # Check if version needs bump or already bumped
          if [ "$CURRENT" = "$MAIN_VERSION" ]; then
            echo "needs_bump=true" >> $GITHUB_OUTPUT
            echo "current_version=$MAIN_VERSION" >> $GITHUB_OUTPUT
            echo "‚úì Version needs bump (matches main: ${MAIN_VERSION})"
          else
            echo "needs_bump=false" >> $GITHUB_OUTPUT
            echo "current_version=$CURRENT" >> $GITHUB_OUTPUT
            echo "‚úì Version already bumped (current: ${CURRENT}, main: ${MAIN_VERSION})"
          fi

      - name: Auto bump version (same-repo non-Dependabot)
        if: steps.repo-check.outputs.is_same_repo == 'true' && steps.check.outputs.needs_bump == 'true' && steps.repo-check.outputs.is_dependabot != 'true'
        id: bump
        env:
          PR_HEAD_REF: ${{ github.head_ref }}
        run: |
          set -euo pipefail

          echo "Running bump-version.js script..."

          # Set GITHUB_HEAD_REF to a safe placeholder value for the Node.js script
          # The script only checks if this var exists (for PR context detection)
          # PR_HEAD_REF is used only to checkout the branch for pushing (see git checkout at line 153)
          export GITHUB_HEAD_REF="pr-branch"
          export CI="true"

          # Run the bump script
          node scripts/bump-version.js

          # Get the new version
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "‚úì Version bumped to ${NEW_VERSION}"

          # Checkout the branch to avoid detached HEAD state for pushing
          # Using env var to safely pass branch name
          BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
          if [ "$BRANCH_NAME" = "HEAD" ]; then
            # We're in detached HEAD, need to checkout the branch
            git checkout -B "$PR_HEAD_REF"
          fi

          # Git identity is configured globally by the GPG action
          # Stage and commit changes
          # Note: Files are explicitly listed (not git add -u) to ensure only version files are committed
          # This matches the files updated by bump-version.js
          git add package.json package-lock.json .example.env public/api-docs/openapi.yaml

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "‚ö†Ô∏è  No changes to commit after running bump script"
            exit 0
          fi

          git commit -m "chore: auto-bump version to v${NEW_VERSION}"
          git push --set-upstream origin "$PR_HEAD_REF"

          echo "‚úì Changes committed and pushed"

      - name: Auto bump version (Dependabot PR)
        if: steps.repo-check.outputs.is_same_repo == 'true' && steps.check.outputs.needs_bump == 'true' && steps.repo-check.outputs.is_dependabot == 'true'
        id: bump-dependabot
        env:
          PR_HEAD_REF: ${{ github.head_ref }}
        run: |
          set -euo pipefail

          echo "Running bump-version.js script..."

          # Set GITHUB_HEAD_REF to a safe placeholder value for the Node.js script
          export GITHUB_HEAD_REF="pr-branch"
          export CI="true"

          # Run the bump script
          node scripts/bump-version.js

          # Get the new version
          NEW_VERSION=$(node -p "require('./package.json').version")
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "‚úì Version bumped to ${NEW_VERSION}"

          # Checkout the branch to avoid detached HEAD state for pushing
          BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD)
          if [ "$BRANCH_NAME" = "HEAD" ]; then
            # We're in detached HEAD, need to checkout the branch
            git checkout -B "$PR_HEAD_REF"
          fi

          # Configure git identity for CI-generated commits (these will not be GPG-signed/Verified)
          # Use the standard github-actions[bot] identity for clarity and auditability
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          # Stage and commit changes
          git add package.json package-lock.json .example.env public/api-docs/openapi.yaml

          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "‚ö†Ô∏è  No changes to commit after running bump script"
            exit 0
          fi

          git commit -m "chore: auto-bump version to v${NEW_VERSION}"
          
          # Push using the token from checkout (BOT_PAT or GITHUB_TOKEN)
          # The token is already configured by actions/checkout above
          git push --set-upstream origin "$PR_HEAD_REF"

          echo "‚úì Changes committed and pushed (commit will be unsigned)"

      - name: Comment on PR (same-repo with auto-bump)
        if: steps.repo-check.outputs.is_same_repo == 'true' && steps.check.outputs.needs_bump == 'true' && (steps.bump.outputs.new_version != '' || steps.bump-dependabot.outputs.new_version != '')
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const newVersion = '${{ steps.bump.outputs.new_version }}' || '${{ steps.bump-dependabot.outputs.new_version }}';
            const isDependabot = '${{ steps.repo-check.outputs.is_dependabot }}' === 'true';

            // Check for existing bump comments to avoid spam on synchronize events
            const { data: comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });

            const bumpPrefix = '‚úÖ **Version automatically bumped to';
            const existingBumpComment = comments
              .slice()
              .reverse()
              .find((comment) => {
                const isBot = comment.user && comment.user.type === 'Bot';
                const hasPrefix = typeof comment.body === 'string' && comment.body.startsWith(bumpPrefix);
                return isBot && hasPrefix;
              });

            const isRebump = !!existingBumpComment;
            const rebumpNote = isRebump
              ? '\n\n_Note: A previous automatic bump was performed. This is a re-bump after the PR was updated (e.g., rebased or synced with main)._'
              : '';
            
            // Check if BOT_PAT was used
            const hasBotPat = '${{ steps.validate-token.outputs.has_bot_pat }}' === 'true';
            
            let signingNote = '';
            if (isDependabot) {
              if (hasBotPat) {
                signingNote = '\n\n_Note: Commit created with BOT_PAT by `github-actions[bot]`. Commit will appear as **unverified** but workflows will trigger normally._';
              } else {
                signingNote = '\n\n‚ö†Ô∏è **Warning**: Commit created with GITHUB_TOKEN (BOT_PAT not configured).\n'
                  + '- Commit will appear as unverified\n'
                  + '- **CI workflows (Tests, Pipeline) will NOT trigger automatically**\n'
                  + '- Please configure BOT_PAT secret to fix this issue';
              }
            }

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `‚úÖ **Version automatically bumped to \`v${newVersion}\`**

            This PR now includes the version bump commit.${rebumpNote}${signingNote}

            **Rollover versioning:** X.Y.Z where X ‚â• 0 and Y, Z ‚àà {0-9}
            - Example: 1.6.9 ‚Üí 1.7.0, 1.9.9 ‚Üí 2.0.0, 9.9.9 ‚Üí 10.0.0

            This PR is ready for review! üöÄ`
            });

      - name: Comment on PR (same-repo, already bumped)
        if: steps.repo-check.outputs.is_same_repo == 'true' && steps.check.outputs.needs_bump == 'false' && github.event.action != 'synchronize'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const currentVersion = '${{ steps.check.outputs.current_version }}';
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `‚úÖ **Version already bumped to \`v${currentVersion}\`**

            No automatic version bump needed - the PR already includes a version update.

            This PR is ready for review! üöÄ`
            });

      - name: Comment on PR (fork, needs bump)
        if: steps.repo-check.outputs.is_same_repo == 'false' && steps.check.outputs.needs_bump == 'true' && github.event.action != 'synchronize'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const nextVersion = '${{ steps.check.outputs.next_version }}';
            const currentVersion = '${{ steps.check.outputs.current_version }}';
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `üëã **Thank you for your contribution from a fork!**

            Since this PR is from a forked repository, the automatic version bump cannot run (for security reasons).

            **Please manually bump the version before merging:**

            \`\`\`bash
            # Current version on main: ${currentVersion}
            # Suggested next version: ${nextVersion}

            # From your PR branch, run the version bump script with PR context:
            CI=true GITHUB_HEAD_REF="$(git rev-parse --abbrev-ref HEAD)" node scripts/bump-version.js
            \`\`\`

            The script will update:
            - \`package.json\` and \`package-lock.json\`
            - \`.example.env\` (NEXT_PUBLIC_APP_VERSION)
            - \`public/api-docs/openapi.yaml\`

            **Rollover versioning:** X.Y.Z where X ‚â• 0 and Y, Z ‚àà {0-9}
            - Example: 1.6.9 ‚Üí 1.7.0, 1.9.9 ‚Üí 2.0.0, 9.9.9 ‚Üí 10.0.0

            For more details, see [VERSIONING.md](https://github.com/${context.repo.owner}/${context.repo.repo}/blob/main/docs/VERSIONING.md).`
            });

      - name: Comment on PR (fork, already bumped)
        if: steps.repo-check.outputs.is_same_repo == 'false' && steps.check.outputs.needs_bump == 'false' && github.event.action != 'synchronize'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          script: |
            const currentVersion = '${{ steps.check.outputs.current_version }}';
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `‚úÖ **Version already bumped to \`v${currentVersion}\`**

            Great! This PR already includes a version update.

            This PR is ready for review! üöÄ`
            });
