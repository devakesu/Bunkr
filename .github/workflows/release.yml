name: Release

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: 'Version bump type'
        required: true
        type: choice
        options:
          - patch
          - minor
          - major
        default: 'patch'
      build_arm64:
        description: 'Build ARM64 architecture (slower, ~5min extra)'
        required: false
        type: boolean
        default: false
  push:
    tags:
      - 'v*.*.*'

permissions:
  contents: read

jobs:
  # Reuse the guard job from pipeline.yml as a prerequisite
  guard:
    name: Build Guard
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

  # Calculate the next version based on trigger type
  calculate-version:
    name: Calculate Version
    needs: guard
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      version_tag: ${{ steps.version.outputs.version_tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0

      - name: Calculate version
        id: version
        run: |
          # If triggered by a tag, use the tag version
          if [[ "${{ github.ref_type }}" == "tag" ]]; then
            VERSION="${{ github.ref_name }}"
            VERSION_TAG="${VERSION}"
            # Remove 'v' prefix if present for version number
            VERSION_NUMBER="${VERSION#v}"
            echo "version=${VERSION_NUMBER}" >> $GITHUB_OUTPUT
            echo "version_tag=${VERSION_TAG}" >> $GITHUB_OUTPUT
            echo "Using tag version: ${VERSION_NUMBER}"
          else
            # Manual dispatch: calculate next version from latest tag
            # Filter to strict semver tags only
            LATEST_TAG=$(git tag -l 'v*.*.*' --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | head -n1)
            
            # Default to v0.0.0 if no valid tags exist
            if [ -z "$LATEST_TAG" ]; then
              LATEST_TAG="v0.0.0"
            fi
            echo "Latest tag: ${LATEST_TAG}"
            
            # Remove 'v' prefix
            LATEST_VERSION="${LATEST_TAG#v}"
            
            # Parse version components
            IFS='.' read -r MAJOR MINOR PATCH <<< "${LATEST_VERSION}"
            
            # Bump version based on input
            case "${{ github.event.inputs.bump_type }}" in
              major)
                MAJOR=$((MAJOR + 1))
                MINOR=0
                PATCH=0
                ;;
              minor)
                MINOR=$((MINOR + 1))
                PATCH=0
                ;;
              patch)
                PATCH=$((PATCH + 1))
                ;;
            esac
            
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
            VERSION_TAG="v${NEW_VERSION}"
            
            echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT
            echo "version_tag=${VERSION_TAG}" >> $GITHUB_OUTPUT
            echo "Calculated new version: ${NEW_VERSION} (${VERSION_TAG})"
          fi

  # Build, sign, and push Docker images
  build-and-release:
    name: Build & Release
    needs: calculate-version
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write
    outputs:
      digest: ${{ steps.build-push.outputs.digest }}
      image_name: ${{ steps.prep.outputs.image_name }}
      platforms: ${{ steps.prep.outputs.platforms }}
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@8d2750c68a42422c14e847fe6c8ac0403b4cbd6f # v3.12.0

      - name: Login to GHCR
        uses: docker/login-action@c94ce9fb468520275223c153574b00df6fe4bcc9 # v3.7.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare derived values
        id: prep
        run: |
          # Validate IMAGE_NAME secret is set
          if [ -z "${{ secrets.IMAGE_NAME }}" ]; then
            echo "âŒ ERROR: IMAGE_NAME secret is not configured"
            echo "Please add IMAGE_NAME secret in repository settings"
            echo "Expected format: lowercase repository name (e.g., 'ghostclass')"
            exit 1
          fi
          
          # Use IMAGE_NAME from secrets (consistent with pipeline.yml)
          IMAGE_NAME="${{ secrets.IMAGE_NAME }}"
          echo "image_name=${IMAGE_NAME}" >> $GITHUB_OUTPUT
          
          # Debug output
          echo "âœ“ Using IMAGE_NAME: ${IMAGE_NAME}"
          echo "  Full image path: ghcr.io/${{ github.repository_owner }}/${IMAGE_NAME}"
          
          # Determine build platforms
          # For tag pushes: Build both AMD64 and ARM64 (full release)
          # For workflow_dispatch: Respect user's build_arm64 input
          if [ "${{ github.event_name }}" == "push" ]; then
            # Tag push - always build multi-arch for full releases
            PLATFORMS="linux/amd64,linux/arm64"
            echo "ðŸ“¦ Tag push detected - building multi-architecture"
          elif [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            if [ "${{ github.event.inputs.build_arm64 }}" == "true" ]; then
              PLATFORMS="linux/amd64,linux/arm64"
              echo "ðŸ“¦ Manual dispatch with ARM64 enabled"
            else
              PLATFORMS="linux/amd64"
              echo "ðŸ“¦ Manual dispatch - AMD64 only (faster build)"
            fi
          else
            # Default fallback
            PLATFORMS="linux/amd64"
          fi
          echo "platforms=${PLATFORMS}" >> $GITHUB_OUTPUT
          echo "  Build platforms: ${PLATFORMS}"
          
          APP_DOMAIN="${{ secrets.NEXT_PUBLIC_APP_DOMAIN }}"
          echo "app_url=https://${APP_DOMAIN}" >> $GITHUB_OUTPUT
          echo "sitemap_url=https://${APP_DOMAIN}/sitemap.xml" >> $GITHUB_OUTPUT
          echo "app_email=@${APP_DOMAIN}" >> $GITHUB_OUTPUT
          echo "legal_email=legal@${APP_DOMAIN}" >> $GITHUB_OUTPUT
          # Use a consistent timestamp for reproducibility
          # Priority: head_commit (for branch pushes) > repository updated (for tags) > current time
          TIMESTAMP="${{ github.event.head_commit.timestamp }}"
          if [ -z "$TIMESTAMP" ] || [ "$TIMESTAMP" == "null" ]; then
            # For tag pushes, use the repository updated timestamp
            TIMESTAMP="${{ github.event.repository.updated_at }}"
          fi
          if [ -z "$TIMESTAMP" ] || [ "$TIMESTAMP" == "null" ]; then
            # Final fallback: current time (for manual dispatches)
            TIMESTAMP=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
          fi
          echo "created=$TIMESTAMP" >> $GITHUB_OUTPUT

      - name: Build & push Docker image
        id: build-push
        uses: docker/build-push-action@10e90e3645eae34f1e60eeb005ba3a3d33f178e8 # v6.19.2
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ github.repository_owner }}/${{ steps.prep.outputs.image_name }}:${{ needs.calculate-version.outputs.version_tag }}
            ghcr.io/${{ github.repository_owner }}/${{ steps.prep.outputs.image_name }}:${{ needs.calculate-version.outputs.version }}
            ${{ github.event_name == 'workflow_dispatch' && format('ghcr.io/{0}/{1}:latest', github.repository_owner, steps.prep.outputs.image_name) || '' }}
          secrets: |
            sentry_token=${{ secrets.SENTRY_AUTH_TOKEN }}
          platforms: ${{ steps.prep.outputs.platforms }}
          
          # Enable layer caching for faster builds
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            APP_COMMIT_SHA=${{ github.sha }}
            SOURCE_DATE_EPOCH=${{ secrets.SOURCE_DATE_EPOCH }}
            NEXT_PUBLIC_BACKEND_URL=${{ secrets.NEXT_PUBLIC_BACKEND_URL }}
            NEXT_PUBLIC_SUPABASE_URL=${{ secrets.NEXT_PUBLIC_SUPABASE_URL }}
            NEXT_PUBLIC_SUPABASE_ANON_KEY=${{ secrets.NEXT_PUBLIC_SUPABASE_ANON_KEY }}
            NEXT_PUBLIC_GITHUB_URL=${{ secrets.NEXT_PUBLIC_GITHUB_URL }}
            NEXT_PUBLIC_SENTRY_DSN=${{ secrets.NEXT_PUBLIC_SENTRY_DSN }}
            NEXT_PUBLIC_TURNSTILE_SITE_KEY=${{ secrets.NEXT_PUBLIC_TURNSTILE_SITE_KEY }}
            NEXT_PUBLIC_GA_ID=${{ secrets.NEXT_PUBLIC_GA_ID }}
            SENTRY_ORG=${{ secrets.SENTRY_ORG }}
            SENTRY_PROJECT=${{ secrets.SENTRY_PROJECT }}
            NEXT_PUBLIC_APP_NAME=${{ secrets.NEXT_PUBLIC_APP_NAME }}
            NEXT_PUBLIC_APP_VERSION=${{ needs.calculate-version.outputs.version }}
            NEXT_PUBLIC_APP_DOMAIN=${{ secrets.NEXT_PUBLIC_APP_DOMAIN }}
            NEXT_PUBLIC_AUTHOR_NAME=${{ secrets.NEXT_PUBLIC_AUTHOR_NAME }}
            NEXT_PUBLIC_AUTHOR_URL=${{ secrets.NEXT_PUBLIC_AUTHOR_URL }}
            NEXT_PUBLIC_LEGAL_EFFECTIVE_DATE=${{ secrets.NEXT_PUBLIC_LEGAL_EFFECTIVE_DATE }}
            NEXT_PUBLIC_APP_URL=${{ steps.prep.outputs.app_url }}
            NEXT_PUBLIC_SITEMAP_URL=${{ steps.prep.outputs.sitemap_url }}
            NEXT_PUBLIC_APP_EMAIL=${{ steps.prep.outputs.app_email }}
            NEXT_PUBLIC_LEGAL_EMAIL=${{ steps.prep.outputs.legal_email }}
          labels: |
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.created=${{ steps.prep.outputs.created }}
            org.opencontainers.image.version=${{ needs.calculate-version.outputs.version }}

      # Attest build provenance
      - name: Attest Build Provenance
        uses: actions/attest-build-provenance@96278af6caaf10aea03fd8d33a09a777ca52d62f # v3.2.0
        with:
          subject-name: ghcr.io/${{ github.repository_owner }}/${{ steps.prep.outputs.image_name }}
          subject-digest: ${{ steps.build-push.outputs.digest }}
          push-to-registry: true

      # Generate SBOM
      - name: Generate SBOM
        uses: anchore/sbom-action@28d71544de8eaf1b958d335707167c5f783590ad # v0.22.2
        with:
          image: ghcr.io/${{ github.repository_owner }}/${{ steps.prep.outputs.image_name }}@${{ steps.build-push.outputs.digest }}
          format: cyclonedx-json
          output-file: sbom.json

      # Attest SBOM
      - name: Attest SBOM
        uses: actions/attest-sbom@4651f806c01d8637787e274ac3bdf724ef169f34 # v3.0.0
        with:
          subject-name: ghcr.io/${{ github.repository_owner }}/${{ steps.prep.outputs.image_name }}
          subject-digest: ${{ steps.build-push.outputs.digest }}
          sbom-path: sbom.json
          push-to-registry: true

      # Sign image with cosign (keyless signing using OIDC)
      - name: Install cosign
        uses: sigstore/cosign-installer@faadad0cce49287aee09b3a48701e75088a2c6ad # v4.0.0

      - name: Authenticate cosign with registry
        run: |
          echo "${{ secrets.GITHUB_TOKEN }}" | cosign login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Sign image (keyless)
        env:
          COSIGN_YES: "true"
          IMAGE_URI: ghcr.io/${{ github.repository_owner }}/${{ steps.prep.outputs.image_name }}@${{ steps.build-push.outputs.digest }}
        run: |
          set -euo pipefail
          
          echo "=== Cosign Image Signing ==="
          echo "Image URI: ${IMAGE_URI}"
          echo "Version: ${{ needs.calculate-version.outputs.version }}"
          
          # Sign with timeout
          timeout 300 cosign sign \
            -a "repo=${{ github.repository }}" \
            -a "workflow=${{ github.workflow }}" \
            -a "ref=${{ github.ref }}" \
            -a "version=${{ needs.calculate-version.outputs.version }}" \
            "${IMAGE_URI}" || {
              echo "ERROR: Cosign image signing failed or timed out"
              exit 1
            }
          
          echo "âœ“ Image signed successfully"
          cosign triangulate "${IMAGE_URI}"

      - name: Verify image signature
        env:
          IMAGE_URI: ghcr.io/${{ github.repository_owner }}/${{ steps.prep.outputs.image_name }}@${{ steps.build-push.outputs.digest }}
        run: |
          set -euo pipefail
          
          cosign verify \
            --certificate-identity-regexp="^https://github.com/${{ github.repository }}/.github/workflows/" \
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \
            "${IMAGE_URI}"
          
          echo "âœ“ Image signature verified"

      # Sign SBOM file
      - name: Sign SBOM artifact
        run: |
          set -euo pipefail
          
          echo "=== Signing SBOM ==="
          timeout 60 cosign sign-blob --yes \
            --bundle sbom.json.bundle \
            sbom.json || {
              echo "ERROR: SBOM signing failed or timed out"
              exit 1
            }
          
          echo "âœ“ SBOM signed successfully"

      # Generate SHA256 checksums (after all artifacts are created)
      - name: Generate checksums
        run: |
          echo "# Release Artifact Checksums" > checksums.txt
          echo "" >> checksums.txt
          echo "## SBOM" >> checksums.txt
          sha256sum sbom.json >> checksums.txt
          echo "" >> checksums.txt
          echo "## Signature Bundle" >> checksums.txt
          sha256sum sbom.json.bundle >> checksums.txt
          echo "" >> checksums.txt
          echo "Generated at: $(date -u +'%Y-%m-%d %H:%M:%S UTC')" >> checksums.txt
          echo "" >> checksums.txt
          cat checksums.txt

      # Upload artifacts for the release job
      - name: Upload release artifacts
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: release-artifacts
          path: |
            sbom.json
            sbom.json.bundle
            checksums.txt

  # Create GitHub Release with artifacts
  create-github-release:
    name: Create GitHub Release
    needs: [calculate-version, build-and-release]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 0

      - name: Download artifacts
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 # v7.0.0
        with:
          name: release-artifacts
          path: ./artifacts

      - name: Verify downloaded artifacts
        run: |
          echo "Downloaded artifacts:"
          ls -lah ./artifacts/
          echo ""
          echo "Checksums:"
          cat ./artifacts/checksums.txt

      - name: Calculate previous version for changelog
        id: prev_version
        run: |
          # Get version tags only (strict semantic version pattern: v[0-9]+.[0-9]+.[0-9]+)
          CURRENT_TAG="${{ needs.calculate-version.outputs.version_tag }}"
          
          # Get the previous semantic version tag (strict pattern matching)
          PREV_TAG=$(git tag -l 'v*.*.*' --sort=-version:refname | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' | grep -v "^${CURRENT_TAG}$" | head -n1 || echo "")
          
          if [ -z "$PREV_TAG" ]; then
            echo "No previous version tag found, using initial commit"
            PREV_REF=$(git rev-list --max-parents=0 HEAD)
            echo "prev_ref=${PREV_REF}" >> $GITHUB_OUTPUT
            echo "changelog_text=${PREV_REF}...${CURRENT_TAG}" >> $GITHUB_OUTPUT
          else
            echo "Previous tag: ${PREV_TAG}"
            echo "prev_ref=${PREV_TAG}" >> $GITHUB_OUTPUT
            echo "changelog_text=${PREV_TAG}...${CURRENT_TAG}" >> $GITHUB_OUTPUT
          fi

      - name: Generate verification instructions
        env:
          IMAGE_NAME: ${{ needs.build-and-release.outputs.image_name }}
          PLATFORMS: ${{ needs.build-and-release.outputs.platforms }}
        run: |
          # Convert platforms to readable format (same transformation as release notes)
          PLATFORM_LIST=$(echo "${PLATFORMS}" | sed 's/linux\///g; s/,/, /g')
          
          cat > ./artifacts/VERIFY.md << EOF
          # Release Verification Instructions

          This release includes signed artifacts and attestations for supply chain security.

          ## Verify Docker Image Signature

          Using cosign (keyless verification):

          \`\`\`bash
          cosign verify \\
            --certificate-identity-regexp="^https://github.com/${{ github.repository }}" \\
            --certificate-oidc-issuer="https://token.actions.githubusercontent.com" \\
            ghcr.io/${{ github.repository_owner }}/${IMAGE_NAME}:${{ needs.calculate-version.outputs.version_tag }}
          \`\`\`

          ## Verify Build Attestation

          Using GitHub CLI:

          \`\`\`bash
          gh attestation verify oci://ghcr.io/${{ github.repository_owner }}/${IMAGE_NAME}:${{ needs.calculate-version.outputs.version_tag }} --owner ${{ github.repository_owner }}
          \`\`\`

          ## Verify SBOM Signature

          Using cosign:

          \`\`\`bash
          cosign verify-blob \\
            --bundle sbom.json.bundle \\
            sbom.json
          \`\`\`

          ## Verify Checksums

          Download the checksums file and verify the artifacts:

          \`\`\`bash
          # Verify all artifacts (extract only checksum lines)
          grep -E '^[0-9a-f]{64}  ' checksums.txt | sha256sum -c
          
          # Or verify individual files
          sha256sum sbom.json sbom.json.bundle
          \`\`\`

          ## Image Information

          - **Image**: \`ghcr.io/${{ github.repository_owner }}/${IMAGE_NAME}:${{ needs.calculate-version.outputs.version_tag }}\`
          - **Digest**: \`${{ needs.build-and-release.outputs.digest }}\`
          - **Platforms**: \`${PLATFORM_LIST}\`
          - **Version**: \`${{ needs.calculate-version.outputs.version }}\`

          ## Additional Tags

          This release is also available under the following tags:
          - \`ghcr.io/${{ github.repository_owner }}/${IMAGE_NAME}:latest\` (manual dispatch only)
          - \`ghcr.io/${{ github.repository_owner }}/${IMAGE_NAME}:${{ needs.calculate-version.outputs.version }}\`

          ## Learn More

          - [Sigstore Cosign Documentation](https://docs.sigstore.dev/cosign/overview/)
          - [GitHub Attestations Documentation](https://docs.github.com/en/actions/security-guides/using-artifact-attestations-to-establish-provenance-for-builds)
          - [SBOM Overview](https://www.cisa.gov/sbom)
          EOF

      - name: Create GitHub Release
        env:
          IMAGE_NAME: ${{ needs.build-and-release.outputs.image_name }}
          PLATFORMS: ${{ needs.build-and-release.outputs.platforms }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Convert platforms to readable format for release notes
          PLATFORM_LIST=$(echo "${PLATFORMS}" | sed 's/linux\///g; s/,/, /g')
          
          # Determine if multi-platform
          if [[ "${PLATFORMS}" == *","* ]]; then
            PLATFORM_DESC="Multi-platform Docker images (${PLATFORM_LIST})"
          else
            PLATFORM_DESC="Docker image (${PLATFORM_LIST})"
          fi
          
          gh release create "${{ needs.calculate-version.outputs.version_tag }}" \
            --title "Release ${{ needs.calculate-version.outputs.version_tag }}" \
            --notes "## Release ${{ needs.calculate-version.outputs.version_tag }}

          This release includes:
          - ðŸ³ ${PLATFORM_DESC}
          - ðŸ” Signed images and artifacts using Sigstore cosign
          - ðŸ“‹ Software Bill of Materials (SBOM) in CycloneDX format
          - âœ… Build provenance attestations
          - ðŸ” SHA256 checksums for all artifacts

          ### Docker Images

          \`\`\`bash
          docker pull ghcr.io/${{ github.repository_owner }}/${IMAGE_NAME}:${{ needs.calculate-version.outputs.version_tag }}
          \`\`\`

          **Image Digest**: \`${{ needs.build-and-release.outputs.digest }}\`

          ### Verification

          See [VERIFY.md](https://github.com/${{ github.repository }}/releases/download/${{ needs.calculate-version.outputs.version_tag }}/VERIFY.md) for detailed verification instructions.

          ### Quick Verification

          \`\`\`bash
          # Verify image signature
          cosign verify \\
            --certificate-identity-regexp=\"^https://github.com/${{ github.repository }}\" \\
            --certificate-oidc-issuer=\"https://token.actions.githubusercontent.com\" \\
            ghcr.io/${{ github.repository_owner }}/${IMAGE_NAME}:${{ needs.calculate-version.outputs.version_tag }}

          # Verify attestation
          gh attestation verify oci://ghcr.io/${{ github.repository_owner }}/${IMAGE_NAME}:${{ needs.calculate-version.outputs.version_tag }} --owner ${{ github.repository_owner }}
          \`\`\`

          ---

          **Full Changelog**: ${{ github.server_url }}/${{ github.repository }}/compare/${{ steps.prev_version.outputs.changelog_text }}" \
            ./artifacts/sbom.json \
            ./artifacts/sbom.json.bundle \
            ./artifacts/checksums.txt \
            ./artifacts/VERIFY.md \
            --draft=false

  # Deploy to production after successful release creation
  # This ensures deployment only happens after the full release completes successfully
  deploy-to-production:
    name: Deploy to Production
    needs: [calculate-version, build-and-release, create-github-release]
    runs-on: ubuntu-latest
    # Only deploy on tag pushes (not manual workflow_dispatch)
    if: github.event_name == 'push' && github.ref_type == 'tag'
    steps:
      - name: Trigger Coolify deployment
        env:
          COOLIFY_BASE_URL: ${{ secrets.COOLIFY_BASE_URL }}
          COOLIFY_APP_ID: ${{ secrets.COOLIFY_APP_ID }}
          COOLIFY_API_TOKEN: ${{ secrets.COOLIFY_API_TOKEN }}
        run: |
          set -euo pipefail
          
          # Validate required Coolify configuration
          : "${COOLIFY_BASE_URL:?COOLIFY_BASE_URL secret is required}"
          : "${COOLIFY_APP_ID:?COOLIFY_APP_ID secret is required}"
          : "${COOLIFY_API_TOKEN:?COOLIFY_API_TOKEN secret is required}"
          
          echo "Deploying version ${{ needs.calculate-version.outputs.version_tag }} to Coolify"
          echo "Note: Ensure Coolify is configured to pull the versioned tag (e.g., ${{ needs.calculate-version.outputs.version_tag }})"
          
          curl --fail-with-body --silent --show-error \
            "$COOLIFY_BASE_URL/api/v1/deploy?uuid=$COOLIFY_APP_ID" \
            -H "Authorization: Bearer $COOLIFY_API_TOKEN"
          
          echo "âœ“ Deployment triggered successfully"
